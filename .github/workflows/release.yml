name: Combined Release Workflow

on:
  workflow_dispatch:
    inputs:
      sprint_number:
        description: "Sprint number for this release"
        required: true

jobs:
  determine_state:
    runs-on: ubuntu-latest
    outputs:
      release_type: ${{ steps.check_type.outputs.release_type }}
      release_tag: ${{ steps.check_type.outputs.release_tag }}
      release_branch: ${{ steps.check_type.outputs.release_branch }}
      rc_tag_match: ${{ steps.check_type.outputs.rc_tag_match }}
    steps:
      - name: Set up environment variables
        run: |
          echo "SPRINT_NUMBER=${{ github.event.inputs.sprint_number }}" >> $GITHUB_ENV
          echo "SOURCE_BRANCH=${{ github.ref }}" >> $GITHUB_ENV
          echo "RELEASE_BRANCH=release-v2.${{ github.event.inputs.sprint_number }}" >> $GITHUB_ENV

      - name: Checkout Repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for all tags and branches

      - name: Determine release type
        id: check_type
        run: |
          set -e
          folder="."

          # Get latest commit and tags
          latest_commit=$(git rev-parse HEAD)
          latest_tag=$(git describe --tags --exact-match "$latest_commit" 2>/dev/null || echo "")

          # # Check for RC and production tags for current sprint
          # rc_tag_match=$(git tag --list 'v2.${{ env.SPRINT_NUMBER }}.*-rc' --sort=-v:refname | head -n1)
          # prod_tag_match=$(git tag | grep -E "v2\.${{ env.SPRINT_NUMBER }}\.\d*$" || echo "")

          # # Get latest tag of any type for sprint
          # latest_tag=$(git tag --list "v2.${SPRINT_NUMBER}.*" | sort -V | tail -n1)

          # Get latest RC tag for sprint
          rc_tag_match=$(git tag --list "v2.${SPRINT_NUMBER}.*-rc" | sort -V | tail -n1)

          # Get latest production tag for sprint
          prod_tag_match=$(git tag --list "v2.${SPRINT_NUMBER}.*" | grep -v -rc | sort -V | tail -n1)


          # Check release branch status
          latest_commit_in_release_branch=$(git rev-parse --verify "${{ env.RELEASE_BRANCH }}" 2>/dev/null || echo "")
          tag_on_latest_commit_in_release_branch=$(git describe --tags --exact-match "$latest_commit_in_release_branch" 2>/dev/null || echo "")

          # Determine release type based on conditions
          if [ -n "$latest_commit_in_release_branch" ] && [ -z "$tag_on_latest_commit_in_release_branch" ]; then
            # Release branch exists and has untagged commits - New RC release
            echo "release_type=new_rc_release" >> $GITHUB_OUTPUT

            # ----- determine release tag -----
            # determine release tag, if there are no tags in the release branch, then it is the first RC
            if [ -z "$rc_tag_match" ]; then
              echo "release_tag=v2.${{ env.SPRINT_NUMBER }}.0-rc" >> $GITHUB_OUTPUT
            else
              IFS='.' read -r major minor patch <<< "${rc_tag_match#v}"  # Extract major, minor, and patch versions
              patch=${patch%%-*}  # Remove any suffix from minor version
              new_patch=$((patch + 1))  # Increment the minor version
              new_rc_version="${major}.${minor}.${new_patch}-rc"  # Construct the new RC version

              echo "release_tag=${new_rc_version}" >> $GITHUB_OUTPUT
            fi

          elif [ -n "$tag_on_latest_commit_in_release_branch" ] && [ -z "$prod_tag_match" ]; then
            # RC tag exists but no production tag - Production release
            echo "release_type=production_release" >> $GITHUB_OUTPUT

            # ----- determine release tag -----
            echo "release_tag=${tag_on_latest_commit_in_release_branch%-rc}" >> $GITHUB_OUTPUT
          else
            echo "release_type=no_new_code" >> $GITHUB_OUTPUT
          fi

          echo "release_branch=${{ env.RELEASE_BRANCH }}" >> $GITHUB_OUTPUT

          # Debug output
          echo "Latest commit: $latest_commit"
          echo "Latest tag: $latest_tag"
          echo "RC tags: $rc_tag_match"
          echo "Production tags: $prod_tag_match"
          echo "Release branch commit: $latest_commit_in_release_branch"
          echo "Tags on release branch: $tag_on_latest_commit_in_release_branch"
          echo "Determined release type: $(cat $GITHUB_OUTPUT | grep release_type | cut -d= -f2)"
  rc_release:
    needs: determine_state
    if: ${{ needs.determine_state.outputs.release_type == 'new_rc_release' }}
    runs-on: ubuntu-latest
    steps:
      - name: Load env
        run: |
          echo "release_type=${{ needs.determine_state.outputs.release_type }}"
          echo "release_tag=${{ needs.determine_state.outputs.release_tag }}"
          echo "release_branch=${{ needs.determine_state.outputs.release_branch }}"

      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Create RC Tag and Release
        run: |
          gh release create ${release_tag} --target ${release_branch} -t "${release_tag}" -d -p --generate-notes

  production_release:
    needs: determine_state
    if: ${{ needs.determine_state.outputs.release_type == 'production_release' }}
    runs-on: ubuntu-latest
    environment: production
    # The environment 'production' should be protected so that it requires approval.
    steps:
      - name: Load env
        run: |
          echo "release_type=${{ needs.determine_state.outputs.release_type }}"
          echo "release_tag=${{ needs.determine_state.outputs.release_tag }}"
          echo "release_branch=${{ needs.determine_state.outputs.release_branch }}"

      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Create Production Tag and Release
        run: |
          gh release create ${release_tag} --target ${release_branch} -t "${new_version}" -d --latest --generate-notes

      - name: Notify Stakeholders
        run: |
          echo "Production release created: $NEXT_TAG"
          # Add your notification logic here (e.g., Slack API, email, etc.)
